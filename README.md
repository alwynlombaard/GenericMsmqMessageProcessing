Generic Msmq Message Processing
============================
By Alwyn Lombaard

This implementation is non transactional. I have used it in a scenario to record non vital analytics events generated by a web application.

Usage
-----

Declare a message to process.

```C#
class MyMessage : IMessage
{

}
``` 

###Server###

Declare a Handler for MyMessage (see https://github.com/davidwhitney/ReallySimpleEventing)

```C#
class MyHandler : IHandle<MyMessage>
{
	public void Handle(MyMessage message)
	{
		//handle your message here
		...
	}
	
	public void OnError(MyMessage message, Exception ex)
	{
		//handle your errors here
		...
	}
}
``` 


Start a message processor for MyMessage. Typically at app start. 

```C#
var messageHandler = new MessageHandler<MyMessage>(eventstream);

var inboundMessageQueue = new MsmqMessageQueueInbound<MyMessage>(logger);

var messageProcessor = new MessageProcessor<MyMessage>(	logger, 
														inboundMessageQueue, 
														messageHandler);

messageProcessor.Start();
``` 

To stop the processor:

```C#
messageProcessor.Stop();
```


###Client###

Add a message to the queue.

```C#
...
try
{
	var queue = new MsmqMessageQueueOutbound<MyMessage>();
	var message = new MyMessage();
	queue.Send(message);
}
catch (Exception ex)...
``` 

###Container setup###
see https://github.com/davidwhitney/ReallySimpleEventing for setting up ReallySimpleEventing

Ninject example bindings:

####MessageProcessor####
```C#
Bind(typeof (IMessageQueueInbound<>))
.To(typeof (MsmqMessageQueueInbound<>));

Bind(typeof(IMessageHandler<>))
.To(typeof(MessageHandler<>));

Bind<ILog>()
.ToMethod(x =>
{
	var type = x.Request.ParentRequest != null 
		? x.Request.ParentRequest.Service 
		: x.Request.Service;
	return LogManager.GetLogger(type);
});
```


Based on Msmq code by https://github.com/michaellperry
and made really simple by https://github.com/davidwhitney/ReallySimpleEventing

